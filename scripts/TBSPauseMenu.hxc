import flixel.FlxG;
import flixel.group.FlxTypedSpriteGroup;
import flixel.math.FlxMath;
import flixel.text.FlxText;
import flixel.text.FlxTextBorderStyle;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import flixel.util.FlxColor;
import flixel.util.FlxStringUtil;
import funkin.audio.FunkinSound;
import funkin.graphics.FunkinSprite;
import funkin.modding.events.ScriptEvent;
import funkin.modding.ModStore;
import funkin.modding.module.ScriptedModule;
import funkin.play.PauseSubState;
import funkin.play.PlayState;
import funkin.ui.FullScreenScaleMode;
import funkin.ui.options.OptionsState;
import funkin.util.FileUtilSandboxed;
import funkin.util.ReflectUtil;
import haxe.Timer;
import haxe.ui.util.MathUtil;

class TBSPauseMenu extends ScriptedModule {
    var playState(get, never):PlayState;
    function get_playState():PlayState { return PlayState.instance; }

    var wasPaused(get, set):Bool;
    function set_wasPaused(value:Bool) { ModStore.stores.set("wasPausedTBS", value); }
    function get_wasPaused():Bool { return ModStore.get("wasPausedTBS"); }

    public static var BLOCK_ENTRIES:Array<String> = ["Enable Practice Mode"];

    var bg:FunkinSprite;
    var box:FunkinSprite;
    var arrow:FunkinSprite;
    var characters:Array<FunkinSprite> = [];
    var charNames = ["char1", "char3", "char2"];
    var charIndices = [0, 2, 1];

    var timeText:FlxText;
    var boxGrowProgress:Float = 0;

    var pauseConfig:PauseConfig;

    override public function onSongLoaded(event:SongLoadScriptEvent) {
        pauseConfig = FileUtilSandboxed.readJSONFromPath(Assets.getPath(Paths.json("pauseChars")));
    }

    override public function onUpdate(event:UpdateScriptEvent) {
        if (playState == null || !TBSHud.SONG_LIST.contains(playState.currentSong.id)) return;
        var subState = FlxG.state.subState;
        if (subState == null) return;

        var pauseState:PauseSubState = null;
        if (subState is PauseSubState) pauseState = subState;
        else if (subState.subState is PauseSubState) pauseState = subState.subState;

        if (!(pauseState is PauseSubState)) return;

        if (box != null) {
            boxGrowProgress += event.elapsed * 0.25;
            var fakeElapsed:Float = MathUtil.clamp(boxGrowProgress, 0, 1);
            box.scale.x = FlxMath.lerp(box.scale.x, 0.6, fakeElapsed);
            box.scale.y = FlxMath.lerp(box.scale.y, 0.62, fakeElapsed);
        }

        if (arrow != null) {
            var lerpVal:Float = MathUtil.clamp(event.elapsed * 18.6, 0, 1);
            var entry = pauseState.menuEntryText.members[pauseState.currentEntry];
            var targetX = entry.x - arrow.width * 0.5 - 30;
            var targetY = entry.y + entry.height * 0.5 - arrow.height * 0.5;
            arrow.setPosition(FlxMath.lerp(arrow.x, targetX, lerpVal), FlxMath.lerp(arrow.y, targetY, lerpVal));
        }

        if (pauseState.controls.UI_UP_P) Timer.delay(() -> TBSMain.playScrollSound(0.4), 1);
        if (pauseState.controls.UI_DOWN_P) Timer.delay(() -> TBSMain.playScrollSound(0.4), 1);
    }

    override public function onSubStateOpenBegin(event:SubStateScriptEvent) {
        if (!wasPaused) return;
        if (event.targetState is PlayState) return;
        FlxG.switchState(() -> new PlayState(PlayState.lastParams));
        wasPaused = false;
    }

    override public function onSubStateOpenEnd(event:SubStateScriptEvent) {
        if (playState == null) return;
        if (!TBSHud.SONG_LIST.contains(playState.currentSong.id)) return;
        if (!(event.targetState is PauseSubState)) return;
        var pauseState:PauseSubState = event.targetState;
        boxGrowProgress = 0;
        startPauseMusic(pauseState);
        buildBackground(pauseState);
        buildCharacters(pauseState);
        clearAndAddMenuEntries(pauseState);
        pauseState.menuEntryText.zIndex = 100;
        pauseState.metadata.forEach(text -> text.font = Paths.font("TBS.ttf"));
        pauseState.metadata.zIndex = 100;
        pauseState.refresh();

        TBSMain.playSound("scrollMenuTBS");
        FlxTween.tween(bg, {alpha: 0.6}, 0.4, {ease: FlxEase.quartInOut});
    }

    override public function onSubStateCloseEnd(event:SubStateScriptEvent) {
        if (event.targetState is PauseSubState) destroyPauseAssets();
    }

    function buildBackground(state:PauseSubState) {
        bg = new FunkinSprite().makeSolidColor(FlxG.width, FlxG.height, FlxColor.BLACK);
        bg.alpha = 0;
        bg.scrollFactor.set();
        state.add(bg);

        timeText = new FlxText(0, 50, 0, "", 64);
        timeText.setFormat(Paths.font("TBS.ttf"), 44, FlxColor.WHITE, "center", FlxTextBorderStyle.OUTLINE, FlxColor.BLACK);
        timeText.scrollFactor.set();
        timeText.borderSize = 2;
        timeText.text = FlxStringUtil.formatTime(Math.max(0, Math.floor(playState.conductorInUse.songPosition / 1000)), false) + ' - ' + FlxStringUtil.formatTime(Math.max(0, Math.floor(playState.currentSongLengthMs / 1000)), false);
        state.add(timeText);

        box = FunkinSprite.create(0 + (FullScreenScaleMode.gameCutoutSize.x * 0.5), 0, "pause/box");
        box.scale.set(0.2, 0.21);
        box.screenCenter();

        arrow = FunkinSprite.create(219 + (FullScreenScaleMode.gameCutoutSize.x * 0.5), 0, "pause/arrow");
        arrow.alpha = 0;
        arrow.scale.set(0.07, 0.07);

        state.add(box);
        state.add(arrow);

        FlxTween.tween(arrow, {alpha: 1}, 0.4, {ease: FlxEase.sineInOut});
    }

    function buildCharacters(state:PauseSubState) {
        if (pauseConfig == null) return;

        var songConfig = ReflectUtil.field(pauseConfig.songs, playState.currentSong.id);
        if (songConfig == null) return;

        characters = [null, null, null];

        for (i in 0...charNames.length) {
            var charIndex = charIndices[i];
            var charConfig = ReflectUtil.field(songConfig, charNames[i]);
            if (charConfig == null) continue;

            var char = FunkinSprite.create(0, 0, charConfig.texture);
            char.alpha = 0;

            char.scale.set(charConfig.scale[0], charConfig.scale[1]);

            var startOffset = charConfig.startOffset;
            var targetPos = charConfig.targetPosition;

            var cutoutOffsetX = FullScreenScaleMode.gameCutoutSize.x;
            if (i > 0) targetPos = [targetPos[0] + cutoutOffsetX, targetPos[1]];

            char.setPosition(targetPos[0] + startOffset[0], targetPos[1] + startOffset[1]);

            characters[charIndex] = char;
            state.add(char);

            FlxTween.tween(char, {alpha: 1}, 0.4, {ease: FlxEase.sineInOut});

            var duration = charConfig.tweenDuration != null ? charConfig.tweenDuration : 0.2;
            FlxTween.tween(char, {x: targetPos[0], y: targetPos[1]}, duration, {ease: FlxEase.sineInOut});

/*            if (charConfig.stepChanges == null) continue;
            var stepChange = ReflectUtil.field(charConfig.stepChanges, Std.string(playState.conductorInUse.currentStep));
            if (stepChange == null) continue;
            if (stepChange.texture != null) char.loadTexture(stepChange.texture);
            if (stepChange.offsetChange != null) {
                char.x += stepChange.offsetChange[0];
                char.y += stepChange.offsetChange[1];
            }*/
        }
    }

    function clearAndAddMenuEntries(pauseState:PauseSubState) {
        pauseState.menuEntryText.clear();
        if (pauseState.menuEntryText == null) {
            pauseState.menuEntryText = new FlxTypedSpriteGroup();
            pauseState.menuEntryText.scrollFactor.set(0, 0);
            pauseState.add(pauseState.menuEntryText);
        }
        var entryIndex:Int = 0;
        var toRemove = [];
        pauseState.currentMenuEntries = pauseState.currentMenuEntries.map(entry -> {
            if (entry.text == "Change Difficulty") {
                return {sprite: entry.sprite, text: "Options", callback: state -> openOptions(state)};
            }
            return entry;
        });

        for (entry in pauseState.currentMenuEntries) {
            if (entry == null || BLOCK_ENTRIES.contains(entry.text)) toRemove.push(entry);
            else {
                var text:FlxText = new FlxText(0, 250 + (entryIndex * 62), 0, entry.text);
                text.setFormat(Paths.font("tbs.ttf"), 36, FlxColor.WHITE, "left", FlxTextBorderStyle.OUTLINE, FlxColor.BLACK);
                text.scrollFactor.set(0, 0);
                text.alpha = 0;
                if (entry.text.length > 17) text.scale.set(0.65, 0.65);
                text.updateHitbox();
                text.screenCenter(0x01);

                pauseState.menuEntryText.add(text);

                FlxTween.tween(text, {alpha: 1}, (entryIndex * 0) + 0.1, {ease: FlxEase.sineInOut});

                entryIndex++;
            }
        }
        for (entry in toRemove) pauseState.currentMenuEntries.remove(entry);
    }

    function openOptions(state:PauseSubState) {
        wasPaused = true;
        FlxG.switchState(() -> {
            TBSMain.playMenuMusic("basementMenu");
            return new OptionsState();
        });
    }

    function startPauseMusic(pauseState:PauseSubState) {
        pauseState.pauseMusic.stop();
        pauseState.pauseMusic = FunkinSound.load(Paths.music("pauseTBS"), true, true);
        pauseState.pauseMusic.play(false, FlxG.random.int(0, Std.int(pauseState.pauseMusic.length / 2)));
        pauseState.pauseMusic.fadeIn(PauseSubState.MUSIC_FADE_IN_TIME, 0, PauseSubState.MUSIC_FINAL_VOLUME);
    }

    function destroyPauseAssets() {
        if (bg != null) {
            FlxTween.cancelTweensOf(bg);
            bg = null;
        }

        if (box != null) {
            FlxTween.cancelTweensOf(box);
            box = null;
        }

        if (arrow != null) {
            FlxTween.cancelTweensOf(arrow);
            arrow = null;
        }

        if (timeText != null) {
            timeText = null;
        }

        if (characters != null) {
            for (char in characters) {
                if (char != null) {
                    FlxTween.cancelTweensOf(char);
                    // char.destroy(); // Don't destroy - the state will handle it
                }
            }
            characters = [];
        }

        boxGrowProgress = 0;
    }
}