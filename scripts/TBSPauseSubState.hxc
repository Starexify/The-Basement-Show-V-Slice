import flixel.FlxG;
import flixel.group.FlxTypedSpriteGroup;
import flixel.math.FlxMath;
import flixel.text.FlxText;
import flixel.text.FlxTextBorderStyle;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import flixel.util.FlxColor;
import funkin.audio.FunkinSound;
import funkin.graphics.FunkinSprite;
import funkin.play.cutscene.VideoCutscene;
import funkin.play.PauseMode;
import funkin.play.PauseSubState;
import funkin.play.PlayState;
import funkin.ui.ScriptedMusicBeatSubState;
import haxe.ui.util.MathUtil;

class TBSPauseSubState extends ScriptedMusicBeatSubState {
    public var PAUSE_MENU_ENTRIES_STANDARD:Array<TBSPauseEntry> = [
        {text: "Resume", callback: state -> resume(state)},
        {text: 'Restart Song', callback: state -> restartPlayState(state)},
        {text: 'Options', callback: state -> openOptions(state)},
        {text: 'Exit to menu', callback: state -> quitToMenu(state)},
    ];

    var pauseMusic:FunkinSound;
    var pauseState:PauseSubState;

    var currentMode:PauseMode;
    var currentEntry:Int = 0;

    var currentMenuEntries:Array<TBSPauseEntry>;
    var menuEntryText:FlxTypedSpriteGroup<FlxText>;

    var bg:FunkinSprite;
    var box:FunkinSprite;
    var arrow:FunkinSprite;
    var char1:FunkinSprite;
    var char2:FunkinSprite;
    var char3:FunkinSprite;

    public function new(pause:PauseSubState, ?mode:PauseMode) {
        super();
        pauseState = pause;
        currentMode = mode ?? PauseMode.Standard;
    }

    override function create() {
        super.create();
        startPauseMusic();
        buildBackground();
        regenerateMenu();
        FlxTween.tween(bg, {alpha: 0.6}, 0.4, {ease: FlxEase.quartInOut});
    }

    function buildBackground() {
        bg = new FunkinSprite().makeSolidColor(FlxG.width, FlxG.height, FlxColor.BLACK);
        bg.alpha = 0;
        bg.scrollFactor.set();
        add(bg);

        box = FunkinSprite.create(0, 0, "pause/box");
        box.scale.set(0.2, 0.21);
        box.screenCenter();

        arrow = FunkinSprite.create(219, 0, "pause/arrow");
        arrow.alpha = 0;
        arrow.scale.set(0.07, 0.07);

        char1 = new FunkinSprite();
        char1.alpha = 0;

        char2 = FunkinSprite.create(519, -55, "pause/right");
        char2.alpha = 0;
        char2.scale.set(0.5, 0.5);

        char3 = new FunkinSprite(569, -245);
        char3.alpha = 0;
        char3.scale.set(0.5, 0.5);

        FlxTween.tween(char1, {alpha: 1}, 0.4, {ease: FlxEase.sineInOut});
        FlxTween.tween(char2, {alpha: 1}, 0.4, {ease: FlxEase.sineInOut});
        FlxTween.tween(char3, {alpha: 1}, 0.4, {ease: FlxEase.sineInOut});
        FlxTween.tween(arrow, {alpha: 1}, 0.4, {ease: FlxEase.sineInOut});

        switch (PlayState.instance.currentSong.id) {
            case "house-for-sale":
                char1.loadTexture("pause/left");
                char1.x -= 220;
                char1.y += 50;
                char3.loadTexture("pause/right2");
                FlxTween.tween(char1, {x: -20}, 0.2, {ease: FlxEase.sineInOut});
                FlxTween.tween(char2, {x: 319}, 0.2, {ease: FlxEase.sineInOut});
                FlxTween.tween(char3, {x: 369}, 0.2, {ease: FlxEase.sineInOut});
        }

        add(char1);
        add(char3);
        add(char2);
        add(box);
        add(arrow);
    }

    function regenerateMenu(?targetMode:PauseMode) {
        currentMode = targetMode ?? currentMode;

        currentEntry = 0;
        chooseMenuEntries();
        clearAndAddMenuEntries();
        changeSelection(0);
    }

    function chooseMenuEntries() {
        switch (currentMode) {
            case PauseMode.Standard: currentMenuEntries = PAUSE_MENU_ENTRIES_STANDARD;

        }
    }

    function clearAndAddMenuEntries() {
        if (menuEntryText == null) {
            menuEntryText = new FlxTypedSpriteGroup();
            menuEntryText.scrollFactor.set(0, 0);
            add(menuEntryText);
        }
        menuEntryText.clear();
        var entryIndex:Int = 0;
        var toRemove = [];
        for (entry in currentMenuEntries) {
            if (entry == null) toRemove.push(entry);
            else {
                var text:FlxText = new FlxText(0, 250 + (entryIndex * 62), 0, entry.text);
                text.setFormat(Paths.font("tbs.ttf"), 36, FlxColor.WHITE, "left", FlxTextBorderStyle.OUTLINE, FlxColor.BLACK);
                text.screenCenter(0x01);
                text.scrollFactor.set(0, 0);
                text.alpha = 0;
                menuEntryText.add(text);

                FlxTween.tween(text, {alpha: 1}, (entryIndex * 0) + 0.1, {ease: FlxEase.sineInOut});

                entry.sprite = text;
                entryIndex++;
            }
        }

        for (entry in toRemove) currentMenuEntries.remove(entry);
    }

    override function update(elapsed:Float) {
        super.update(elapsed);

        var fakeElapsed:Float = MathUtil.clamp(elapsed, 0, 1);
        box.scale.x = FlxMath.lerp(box.scale.x, 0.6, fakeElapsed * 18);
        box.scale.y = FlxMath.lerp(box.scale.y, 0.62, fakeElapsed * 18 * 2);

        var lerpVal:Float = MathUtil.clamp(elapsed * 18.6, 0, 1);
        if (currentEntry == 0) {
            arrow.y = FlxMath.lerp(arrow.y, -5, lerpVal);
            arrow.x = FlxMath.lerp(arrow.x, 260, lerpVal);
        } else if (currentEntry == 1) {
            arrow.y = FlxMath.lerp(arrow.y, 62, lerpVal);
            arrow.x = FlxMath.lerp(arrow.x, 219, lerpVal);
        } else if (currentEntry == 2) {
            arrow.y = FlxMath.lerp(arrow.y, 122, lerpVal);
            arrow.x = FlxMath.lerp(arrow.x, 255, lerpVal);
        } else if (currentEntry == 3) {
            arrow.y = FlxMath.lerp(arrow.y, 184, lerpVal);
            arrow.x = FlxMath.lerp(arrow.x, 219, lerpVal);
        }

        if (controls.UI_UP_P) changeSelection(-1);
        if (controls.UI_DOWN_P) changeSelection(1);

        if (controls.ACCEPT && currentMenuEntries.length > 0) {
            currentMenuEntries[currentEntry].callback(this);
        }
    }

    function changeSelection(change:Int) {
        var prevEntry:Int = currentEntry;
        currentEntry += change;

        if (currentEntry < 0) currentEntry = currentMenuEntries.length - 1;
        if (currentEntry >= currentMenuEntries.length) currentEntry = 0;

        if (currentEntry != prevEntry) TBSMain.playSound("scrollMenuTBS", 0.4);
    }

    function resume(state:TBSPauseSubState) {
        VideoCutscene.resumeVideo();
        state.close();
    }

    function restartPlayState(state:TBSPauseSubState) {
        PlayState.instance.needsReset = true;
        state.close();
    }

    function openOptions(state:TBSPauseSubState) {

    }

    function quitToMenu(state:PauseSubState) {
        //state.allowInput = false;
    }

    function startPauseMusic() {
        pauseMusic = FunkinSound.load(Paths.music("pauseTBS"), true, true);
        pauseMusic.play(false, FlxG.random.int(0, Std.int(pauseMusic.length / 2)));
        pauseMusic.fadeIn(PauseSubState.MUSIC_FADE_IN_TIME, 0, PauseSubState.MUSIC_FINAL_VOLUME);
    }

    public override function destroy() {
        super.destroy();
        pauseMusic.stop();
    }
}

typedef TBSPauseEntry = {text:String, callback:TBSPauseSubState -> Void, sprite:FlxText}